import{w as A,f as s,g as i,t as d,h as y,i as u,s as h,q as f,k as D,l as w,m as v,n as l,o as m,p as R,v as g,x as O}from"./index-BFEWtwhJ.js";const o="incidents",b=(n,t)=>{if(!s)return console.error("Firebase not configured! Check your .env file"),t&&t(new Error("Firebase not configured")),n([]),()=>{};try{const e=f(u(s,o),m("createdAt","desc"),O(100));return g(e,r=>{const c=r.docs.map(a=>({id:a.id,...a.data()}));n(c)},r=>{console.error("Subscription error:",r.message),t&&t(r),n([])})}catch(e){return t&&t(e),n([]),()=>{}}},q=async n=>{try{const t=i(s,o,n),e=await R(t);return e.exists()?{id:e.id,...e.data()}:null}catch(t){d(t)}},T=async()=>{try{const n=f(u(s,o),m("createdAt","desc"));return(await w(n)).docs.map(e=>({id:e.id,...e.data()}))}catch(n){d(n)}},F=async n=>{try{return(await y(u(s,o),{...n,status:n.status||"Open",priority:n.priority||"Medium",timeline:[],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),serverTimestamp:h()})).id}catch(t){d(t)}},C=async(n,t)=>{try{const e=i(s,o,n);await v(e,{...t,updatedAt:new Date().toISOString()})}catch(e){d(e)}},x=async n=>{try{const t=i(s,o,n);await l(t)}catch(t){d(t)}},B=(n,t)=>{if(!n)return()=>{};const e=u(s,o,n,"events"),r=f(e);return g(r,c=>{const a=c.docs.map(p=>({id:p.id,...p.data()}));t(a)},c=>console.error("Error subscribing to events sub-collection:",c))},M=n=>n?Object.entries(n).reduce((t,[e,r])=>(r!==void 0&&(t[e]=r),t),{}):{},S=async(n,t)=>{try{console.log("Adding event to incident:",n,t);const e=u(s,o,n,"events"),c={...M(t),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};console.log("Clean payload:",c);const a=await y(e,c),p=i(s,o,n);return await v(p,{updatedAt:h()}),{id:a.id,...c}}catch(e){console.error("Failed to add event:",e),d(e)}},L=async(n,t,e)=>{try{const r=t.id||e.id;if(!r)throw new Error("Event ID missing for update");const c=i(s,o,n,"events",r),a={...e,updatedAt:new Date().toISOString()};return await v(c,a),{id:r,...a}}catch(r){d(r)}},N=async(n,t)=>{try{const e=t.id;if(!e)throw new Error("Event ID missing for delete");const r=i(s,o,n,"events",e);await l(r)}catch(e){d(e)}},j=async n=>{try{const t=u(s,o,n,"events");return(await w(t)).docs.map(r=>({id:r.id,...r.data()}))}catch(t){return console.error("Error fetching events:",t),[]}},k=S,z=async(n,t,e)=>{const r=i(s,o,n,"events",t);await v(r,{...e,updatedAt:new Date().toISOString()})},P=async(n,t)=>{const e=i(s,o,n,"events",t);await l(e)},_=async(n,t)=>{try{const e=A(s);t.forEach((r,c)=>{const a=i(s,o,n,"events",r.id);e.update(a,{order:c,updatedAt:new Date().toISOString()})}),await e.commit()}catch(e){d(e)}},G=async n=>{try{let t=0,e=0;for(const r of n){const c=f(u(s,o),D("ticket","==",r.ticket)),a=await w(c),p={...r,updatedAt:new Date().toISOString()};if(a.empty)await y(u(s,o),{...p,createdAt:r.createdAt||new Date().toISOString(),status:r.status||"Open",priority:r.priority||"Medium",timeline:[]}),t++;else{const I=a.docs[0].id,E=i(s,o,I);await v(E,p),e++}}return{created:t,updated:e}}catch(t){throw console.error("Import Error:",t),t}},J={subscribeIncidents:b,subscribeEvents:B,getIncidentById:q,getIncidents:T,createIncident:F,updateIncident:C,deleteIncident:x,addTimelineEvent:S,updateTimelineEvent:L,deleteTimelineEvent:N,getEvents:j,createEvent:k,updateEvent:z,deleteEvent:P,reorderEvents:_,importIncidentsFromSheet:G};export{J as i,b as s};
