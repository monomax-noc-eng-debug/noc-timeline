import{g as w,h as u,i as r,s as m,t as d,q as y,w as A,k as l,l as i,m as v,n as D,o as h,p as g,v as R,x as S,y as O}from"./index-DeB0UNQi.js";const o="incidents",b=(n,t)=>{if(!r)return console.error("Firebase not configured! Check your .env file"),t&&t(new Error("Firebase not configured")),n([]),()=>{};try{const e=y(u(r,o),g("createdAt","desc"),O(100));return S(e,s=>{const a=s.docs.map(c=>({id:c.id,...c.data()}));n(a)},s=>{console.error("Subscription error:",s.message),t&&t(s),n([])})}catch(e){return t&&t(e),n([]),()=>{}}},q=async n=>{try{const t=i(r,o,n),e=await R(t);return e.exists()?{id:e.id,...e.data()}:null}catch(t){d(t)}},T=async()=>{try{const n=y(u(r,o),g("createdAt","desc"));return(await l(n)).docs.map(e=>({id:e.id,...e.data()}))}catch(n){d(n)}},F=async n=>{try{return(await w(u(r,o),{...n,status:n.status||"Open",priority:n.priority||"Medium",timeline:[],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),serverTimestamp:m()})).id}catch(t){d(t)}},C=async(n,t)=>{try{const e=i(r,o,n);await v(e,{...t,updatedAt:new Date().toISOString()})}catch(e){d(e)}},x=async n=>{try{const t=i(r,o,n);await h(t)}catch(t){d(t)}},B=(n,t,e=null)=>{if(!n)return()=>{};const s=u(r,o,n,"events"),a=y(s);return S(a,c=>{const p=c.docs.map(f=>({id:f.id,...f.data()}));t(p)},c=>{console.error("Error subscribing to events sub-collection:",c),e&&e(c),t([])})},M=n=>n?Object.entries(n).reduce((t,[e,s])=>(s!==void 0&&(t[e]=s),t),{}):{},I=async(n,t)=>{try{console.log("Adding event to incident:",n,t);const e=u(r,o,n,"events"),a={...M(t),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};console.log("Clean payload:",a);const c=await w(e,a),p=i(r,o,n);return await v(p,{updatedAt:m()}),{id:c.id,...a}}catch(e){console.error("Failed to add event:",e),d(e)}},L=async(n,t,e)=>{try{const s=t.id||e.id;if(!s)throw new Error("Event ID missing for update");const a=i(r,o,n,"events",s),c={...e,updatedAt:new Date().toISOString()};return await v(a,c),{id:s,...c}}catch(s){d(s)}},N=async(n,t)=>{try{const e=t.id;if(!e)throw new Error("Event ID missing for delete");const s=i(r,o,n,"events",e);await h(s)}catch(e){d(e)}},j=async n=>{try{const t=u(r,o,n,"events");return(await l(t)).docs.map(s=>({id:s.id,...s.data()}))}catch(t){return console.error("Error fetching events:",t),[]}},z=I,P=async(n,t,e)=>{const s=i(r,o,n,"events",t);await v(s,{...e,updatedAt:new Date().toISOString()})},_=async(n,t)=>{const e=i(r,o,n,"events",t);await h(e)},k=async(n,t)=>{try{const e=D(r);t.forEach((s,a)=>{const c=i(r,o,n,"events",s.id);e.update(c,{order:a,updatedAt:new Date().toISOString()})}),await e.commit()}catch(e){d(e)}},G=async n=>{try{let t=0,e=0;for(const s of n){const a=y(u(r,o),A("ticket","==",s.ticket)),c=await l(a),p={...s,updatedAt:new Date().toISOString()};if(c.empty)await w(u(r,o),{...p,createdAt:s.createdAt||new Date().toISOString(),status:s.status||"Open",priority:s.priority||"Medium",timeline:[]}),t++;else{const f=c.docs[0].id,E=i(r,o,f);await v(E,p),e++}}return{created:t,updated:e}}catch(t){throw console.error("Import Error:",t),t}},J={subscribeIncidents:b,subscribeEvents:B,getIncidentById:q,getIncidents:T,createIncident:F,updateIncident:C,deleteIncident:x,addTimelineEvent:I,updateTimelineEvent:L,deleteTimelineEvent:N,getEvents:j,createEvent:z,updateEvent:P,deleteEvent:_,reorderEvents:k,importIncidentsFromSheet:G};export{J as i,b as s};
